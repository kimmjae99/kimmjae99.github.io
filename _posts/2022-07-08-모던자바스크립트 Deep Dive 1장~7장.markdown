---
layout: post
title:  모던자바스크립트 Deep Dive 1장~7장
date:   2022-07-08 16:30:00 +0300
image:  Javascript.jpg
tags:   Javascript
---

---

# 1.1 프로그래밍이란?

- 프로그래밍 : 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션
- 프로그래밍 : 정확하고 상세하게 요구사항을 설명하는 작업 (결과물 : 코드)

# 1.2 프로그래밍 언어

기계어(machine code) : 컴퓨터가 이해할 수 있는 언어

기계어로 명령을 전달하는 것 : 프로그래밍 언어를 사용해 프로그램을 작성한 후 번역기를 이용하는 것이다. (번역기 : 컴파일러(compiler) 혹은 인터프리터(interpreter)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/018f4fb4-a6a2-49f9-8338-2ea8ffa33a11/Untitled.png)

# 1.3 구문과 의미

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da457d4b-179a-493c-b87b-13edbb0ab611/Untitled.png)

- 문법적으로 문제가 없음
- 의미적으로 문제가 있음
- number라는 이름의 변수에 문자열이 할당되어 있음
- number에는 숫자를 할당하는 것이 의미적으로 옳다

프로그래밍 : 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것



# 2장 자바스크립트란?

---

# 2.1 자바스크립트의 탄생

- 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 도입하기로 결정한다
- 이로 인해 탄생한 것이 자바스크립트

# 2.2 자바스크립트의 표준화

# 2.3 자바스크립트 성장의 역사

## 2.3.1 Ajax(Asynchronous JavaScript and XML) - XMLHttpRequest

- 자바스크립트를 이용해 서버와 브라우저가 비동기(asynchronous)방식으로 데이터를 교환할 수 있는 통신 기능

- 이전에는 html태그로 시작해서 html태그로 끝나는 코드를 전송받아 웹페이지 전체를 렌더링하는 방식으로 동작
- 화면이 전환이 되면 새로운 HTML을 전송받아 웹페이지를 처음부터 다시 렌더링함
- 단점
    - 변경할 필요가 없는 부분까지 다시 전송받기 때문에 불필요한 데이터 통신이 발생
    - 변경할 필요가 없는 부분을 다시 렌더링해야 하기 때문에 성능면에서도 불리
        - 화면이 전환되면 화면이 순간적으로 깜박이는 현상이 발생(웹페이지의 한계로 받아들여짐)

Ajax

- 웹페이지에서 변경할 필요가 없는 부분은 렌더링 하지 않고 변경해야 하는 부분만 한정적으로 렌더링 하는 것이 가능해짐
    - 웹브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 성능과 부드러운 화면 전환을 보여줌
    

## 2.3.2 jQuery

- DOM(Document Object Model)을 더욱 쉽게 저어할 수 있고 크로스 브라우징 이슈도 해결됨
- 자바스크립트보다 배우기 쉽고 직관적임

## 2.3.3 V8 자바스크립트 엔진

- 웹 애플리케이션을 구축하려는 시도가 늘면서 더욱 빠르게 동작하는 자바스크립트 엔진의 필요성이 대두됨
- 그로인해 개발된 V8 자바스크립트 엔진은 이러한 요구에 부합하는 빠른 성능을 보여줌
- 이러한 엔진의 등장으로 자바스크립트는 데스크톱 애플리케이션과 유사한 사용자 경험을 제공할 수 있는 웹 애플리케이션 프로그래밍 언어로 정착하게 됨

## 2.3.4 Node.js

- V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
- 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경
- 다양한 플랫폼에 적용할 수 있지만 사이드 애플리케이션 개발에 주로 사용, API 제공

## 2.3.5 SPA 프레임워크

- 모던 웹 애플리케이션은 데스크톱 애플리케이션과 비교해도 손색없는 성능과 사용자 경험을 제공하는 것이 필수 → 개발 규모와 복잡도도 상승
- 이전의 개발방식으로는 복잡해진 개발 과정을 수행하기 어려워졌고 이러한 필요에 따라 많은 패턴과 라이브러리가 출현 → 하지만 변경에 유연하면서 확장하기 쉬운 애플리케이션 아키텍처의 구축이 어려움
- 이로인해 필연적으로 프레임워크가 등장함

# 2.4 자바스크립트와  ECMAScript

- 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정

자바스크립트 : 일반적으로 프로그래밍언어

- 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API등을 아우르는 개념

# 2.5 자바스크립트의 특징

- 자바스크립트 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/66b5cd10-4b22-41a1-8851-b70a0fcad906/Untitled.png)

- 대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 컴파일러 언어처럼 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거치며 일부 소스코드를 컴파일하고 실행

→ 인터프리터 언어의 장점인 동적기능지원을 살리면서 실행 속도가 느리다는 단점을 극복



# 3장 자바스크립트 개발 환경과 실행 방법

---

# 3.1 자바스크립트 실행 환경

- 모든 브라우저는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있다.
- Node.js도 자바스크립트 엔진을 내장하고 있다.
- 따라서 자바스크립트는 브라우저 환경 또는 Node.js 환경에서 실행할 수 있다.

# 3.2웹브라우저

- 주로 크롬 브라우저를 사용

## 3.2.1 개발자 도구

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8e2773f4-11bc-45da-9020-8f776d8ca67d/Untitled.png)

- 개발자 도구의 기능

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b81cacb6-110b-44d0-b0a6-2c4d3b26ecd4/Untitled.png)

## 3.2.2 콘솔

## 3.2.3 브라우저에서 자바스크립트 실행

## 3.2.4 디버깅

# 3.3 Node.js

## 3.3.1 Node.js와 npm 소개

- Node.js : V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경

→ 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 환경

- npm : 자바스크립트 패키지 매니저
- Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI(Command line interface)를 제공한다



# 4장 변수

---

# 4.1 변수란 무엇인가? 왜 필요한가?

- 애플리케이션은 데이터를 입력받아 처리하고 그 결과를 출력한다.
- 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b99acff2-0d4f-46c5-8192-54adfcc4f72a/Untitled.png)

- 자바스크립트 엔진이 자바스크립트 코드를 계산(평가evaluation)하려면 먼저 10, 20, + 라는 기호(리터럴literal과 연산자operator)의 의미를 알고 있어야 하며 10 + 20 이라는 식(표현식expression)의 의미도 해석(파싱parsing) 할수 있어야 한다.

- 자바스크립트 엔진이 위의 식의 의미를 해석 하려면 + 연산을 수행하기 위해 연산자의 좌변과 우변의 숫자 값, 즉 피연산자operand를 기억한다.

- 메모리 : 데이터를 저장할 수 있는 메모리 셀의 집합체
- 메모리 셀의 크기 : 1바이트(8bit)
- 1바이트의 단위로 데이터를 저장하거나 읽어들인다.
- 각 셀은 고유의 메모리 주소를 갖는다.

변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

- 값의 위치를 가리키는 상징적인 이름
- 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.
- 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/28fd889e-e8a5-43eb-bc2f-fa0b7c403746/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e40317a3-4a93-4033-abe0-abb23b260f87/Untitled.png)

- 10 + 20은 연산을 통해 새로운 값 30을 생성한다.
- 이 새로운 값 30은 메모리 공간에 저장됨
- 이 30 이라는 값을 디시 읽어들여 재사용할 수 있도록 값이 저장된 메모리 공간에 이름을 붙인 것이 바로 변수이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2cfa67f1-b26a-4f4d-ace0-44eedfdd1b24/Untitled.png)

변수에 값을 저장하는 것을 할당assignment(대입, 저장)이라 하고, 변수에 저장된 값을 읽어 들이는 것을 참조reference라 한다.

# 4.2 식별자

- 변수 이름 → 식별자
- 식별자 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.(메모리 주소에 붙인 이름)
- 식별자는 값이 저장되어 있는 메모리 주소와 매핑관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.
- **식별자는 값이 아니라 메모리 주소를 기억하고 있다.**

# 4.3 변수 선언

- 변수 선언 : 변수를 생성하는 것을 말한다.
- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.
- 변수를 사용하려면 반드시 선언이 필요하다.
- var, let, const 키워드 사용

- var 키워드 단점
    - 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원 → 의도치 않게 전역변수가 선언 되어 심각한 부작용이 발생하기도 한다.

var score;   //변수 선언

키워드

- 키워드는 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어다.
- 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다.
- ex) var 키워드를 만나면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다.

- 변수를 선언한 이후 아직 변수에 값을 할당하지 않으면 확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.
- undefined : 자바스크립트에서 제공하는 원시 타입의 값(primitive value)이다.

자바스크립트 엔진의 변수 선언 단계

1. 선언단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.(모든 식별자는 실행 컨텍스트에 등록된다)
2. 초기화단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화 한다.

- 변수를 사용하려면 반드시 선언이 필요하다.(변수뿐만 아니라 모든 식별자(함수, 클래스 등)가 그렇다.)
    - 만약 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생
        - ReferenceError : 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러이다.
        

# 4.4 변수 선언의 실해 시점과 변수 호이스팅

```jsx
console.log(score); // undefined

var score; // 변수 선언문
```

- 일반적으로 자바스크립트는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 console.log(score);가 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행한다.
- console.log(score);가 실행 되고 있을 시점에서는 score변수가 선언이 되어있지 않으므로 ReferenceError가 발생할 것처럼 보이지만 undefined가 출력된다
- 변수 선언이 소스코드가 순차적으로 실행되는 시점(런타임)이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.
- 순차적으로 실행하기에 앞서 소스코드의 평가 과정을 거친다.
- 소스코드의 평가 과정 : 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행하는 것
- 소스코드의 평가 과정이 끝나면 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

- 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라 한다.

# 4.5 값의 할당

- 변수에 값을 할당(대입, 저장)할 때는 할당 연산자 = 을 사용한다.
- 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```jsx
var score; //변수 선언
score = 80; // 값의 할당

//var score = 80;  변수 선언 + 값의 할당
```

- **변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**

```jsx
console.log(score); // undefined

var score; //변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

# 4.6 값의 재할당

```jsx
var score = 80; //변수선언 + 값의 할당
score = 90; // 값의 재할당
```

- 재할당은 변수에 저장된 값을 다른 값을 변경한다.
- 만약 **값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.**

- const키워드
- const키워드를 사용해 선언한 변수는 재할당이 금지된다.

→ 단 한번만 할당할 수 있는 변수를 선언한다. → 상수를 표현할 수 있다.

- 가비지 콜렉터
- 애플리케이션이 할당된 메모리 공간을 주기적으로 검사하여 더이상 사용되지 않는 메모리를 해제하는 기능
- 더이상 사용되지 않는 메모리 → 어떤 식별자도 참조하지 않는 메모리 공간

unmanaged language vs managed language

            C언어                          JavaScript

      malloc(), free()                    X(자동)

# 4.7 식별자 네이밍 규칙

p.47 참조(79)



# 5장 표현식과 문

---

# 5.1 값

- 값(value) : 식(표현식expression)이 평가되어 생성된 결과를 말한다.
- 평가(evaluate) : 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

```jsx
//10 + 20은 평가되어 숫자 값 30을 생성한다.
10 + 20; // 30
```

```jsx
//변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다
var sum = 10 + 20;
```

- sum 변수에 할당된 것은 10 + 20이 아니라 10 + 20이 평가된 결과인 숫자 값 30이다.
- 따라서 10 + 20은 할당 이전에 평가되어 값을 생성해야 한다.

# 5.2 리터럴

- 리터럴 : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)

```jsx
// 숫자 리터럴 3
3
```

- 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성한다.
    - 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.
    
    → 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라 할 수 있다.
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/af21314f-b0a3-452f-bf1e-85f54e53fb9f/Untitled.png)

# 5.3 표현식

- 표현식 : 값으로 평가될 수 있는 문(statement)
- 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

- 표현식은 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다.
- 값으로 평가될 수 있는 문은 모두 표현식이다.
    
    → 표현식과 표현식이 평가된 값은 동등한 관계 : 동치(equivalent)
    
    ex) 1 + 2 = 3 → 1 + 2는 3과 동치이다.
    

```jsx
var x = 1 + 2;

// 식별자 표현식 x는 3으로 평가된다.
x + 3; // -> 6
```

→ 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.

# 5.4 문(명령문)

- 문(statement) : 프로그램을 구성하는 기본 단위이자 최소 실행 단위(컴퓨터에 내리는 명령)
- 문의 집합 → 프로그램
- 문을 작성하고 순서에 맞게 나열하는 것 → 프로그래밍
- 문은 여러 토큰으로 구성
    - 토큰(token) : 문법적인 의미를 가지며 문법적으로 더이상 나눌 수 없는 코드의 기본요소
    - ex) 키워드, 식별자, 연산자, 리터럴, 세미콜론(;), 마침표(.) 등의 특수 기호

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c473723-b78b-45b3-97a5-0adc0e000494/Untitled.png)

- 문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3be47121-2c60-4458-8127-17688e339bf5/Untitled.png)

# 5.5 세미콜론과 세미콜론 자동삽입 기능

# 5.6 표현식인 문과 표현식이 아닌 문

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x;
//1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.
//x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
x = 1 + 2;
```

- 표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것



# 6장 데이터 타입

---

- 데이터 타입 = 값의 종류

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/86052159-8535-442d-a690-7b5cf9411dae/Untitled.png)

# 6.1 숫자타입

- C나 자바의 경우 정수와 실수를 구분해서 int, long, float, double 등과 같은 다양한 숫자 타입을 제공한다.
- 자바스크립트의 경우 하나의 숫자 타입만 존재한다.

```jsx
//모두 숫자타입이다.
var integer = 10; // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수
```

```jsx
var binary = 0b01000001; 이진수
var octal = 0o101; 8진수
var hex = 0x41; 16진수

//표기법만 다를 뿐 모두 같은 값이다.
console.log(binary); // 65
console.log(octal); // 65
console.log(hex); // 65
console.log(binary == octal); // true
console.log(octal == hex); // true

```

- 자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다.

```jsx
console.log(1 === 1.0); //true
console.log(4 / 2); // 2
console.log(3 / 2); // 1.5
```

- 숫자 타입은 추가적으로 3가지 특별한 값도 표현할 수 있다.

```jsx
console.log(10 / 0); //Infinity - 양의 무한대
console.log(10 / -0); //-Infinity - 음의 무한대
console.log(1 * 'String'); // NaN(not a number)
```

# 6.2 문자열 타입

- 문자열 타입은 텍스트 데이터를 나타내는 데 사용
- 문자열은 ‘’, “”, `` 으로 텍스트를 감싼다.

```jsx
//문자열 타입
var string;
string = '문자열'; //작은 따옴표
string = "문자열"; //큰 따옴표
string = `문자열`; //백틱(ES6)
```

- 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식한다

```jsx
//따옴표로 감싸지 않은 hello를 식별자로 인식한다.
var string = hello; // ReferenceError : hello is not defined
```

# 6.3 템플릿 리터럴

- ES6부터 새로운 문자열 표기법으로 도입된 것
- 멀티라인 문자열, 표현식 삽입, 태그드 템플릿
- 런타임에 일반 문자열로 변환되어 처리
- 백틱(` `)을 사용해 표현한다

```jsx
var template = `Template literal`;
console.log(template); // Template literal
```

## 6.3.1 멀티라인 문자열

- 일반 문자열 내에서는 줄바꿈이 허용되지 않는다
- 따라서 일반 문자열 내에서 줄바꿈등의 공백을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용해야 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/52de158a-21b7-41c5-b7f8-6e1aeb9ec2ce/Untitled.png)

```jsx
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';

console.log(template);
```

```jsx
//실행결과
<ul>
	<li><a href="#">Home</a><\li>
</ul>
```

```jsx
var template = `<ul>
	<li><a href="#">Home</a><\li>
</ul>`;

console.log(template);
```

```jsx
//실행결과
<ul>
	<li><a href="#">Home</a><\li>
</ul>
```

## 6.3.2 표현식 삽입

- 문자열은 문자열 연산자 +를 사용해 연결할 수 있다.
- + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

```jsx
var first = 'Ung-mo';
var last = 'Lee';

console.log('My name is ' + first + ' ' + last + '.'); //My name is Ung-mo Lee.
```

```jsx
var first = 'Ung-mo';
var last = 'Lee';

console.log(`My name is ${first} ${last}.`); //My name is Ung-mo Lee. 
```

- 표현식을 삽입하려면 ${}으로 표현식을 감싼다.
- 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다.

```jsx
console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
```

- 표현식 삽입은 반드시 템플릿리터럴 내에서 사용해야 한다.
- 일반 문자열에서의 표현식 삽입은 문자열로 취급된다.

```jsx
console.log('1 + 2 = ${1 + 2}'); // 1 + 2 = ${1 + 2}
```

# 6.4 불리언 타입

- 불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false뿐이다.

```jsx
var foo = true;
console.log(foo); // true

foo = false;
console.log(foo); // false
```

# 6.5 undefined 타입

- undefined 타입의 값은 undefined가 유일하다.

```jsx
var foo;
console.log(foo); // undefined
```

# 6.6 null 타입

- null타입의 값은 null이 유일하다.

```jsx
var foo = 'Lee';
//이전 참조를 제거

foo = null;
```

- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.

```jsx
<!DOCTYPE html>
<html>
<body>
  <script>
    var element = document.querySelector('.myClass');

    //HTML 문서에 myClass 클래스를 갖는 요소가 없다면 null을 반환한다.
    console.log(element); // null
  </script>
</body>
</html>
```

# 6.7 심벌 타입

- 심벌 : 변경 불가능한 원시 타입의 값
- 심벌 값은 다른 값과 중복 되지 않는 유일무이한 값이다.
- 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용

- 심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 symbol 함수를 호출해 생성한다.

```jsx
//심벌값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

//객체 생성
var obj = {};

//이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value
```

# 6.8 객체 타입

- 자바스크립트는 객체 기반의 언어
- 자바스크립트를 이루고 있는 거의 모든 것이 객체이다
- 지금까지 살펴본 6가지 데이터 타입 이외의 값은 모두 객체 타입이다.

# 6.9 데이터 타입의 필요성

## 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

```jsx
//c 변수에는 1바이트 정수 타입의 값(-128 ~ 127)만 할당할 수 있다.
char c;

//num 변수에는 4바이트 정수 타입의 값만 할당할 수 있다.
int num;
```

- 정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
- 정적 타입 언어는 컴파일 시점에 **타입체크**(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행한다.

- typeof 연산자 : 연산자의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다.

```jsx
var foo;
console.log(typeof foo); // undefined

foo = 3;
console.log(typeof foo); // number

foo = 'Hello';
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // boolean

foo = null;
console.log(typeof foo); // object

foo = Symbol();
console.log(typeof foo); // symbol

foo = {};
console.log(typeof foo); // object

foo = [];
console.log(typeof foo); // object

foo = function(){};
console.log(typeof foo); // function
```

- 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환한 것이다.

- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론type inference)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.
- 이러한 특징을 동적 타이핑이라 한다
- 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라 한다.
- ex) 자바스크립트, 파이썬, PHP, 루비, 리스프, 펄 등이 있다.

## 6.10.2 동적 타입 언어와 변수

- 동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.
- 변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.
- 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.
- 동적 탕입 언어의 변수를 사용할 때 주의할 사항

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fdde4b77-e6e9-472e-9ab6-d0bf4caf7f7e/Untitled.png)

결론 : 가독성이 좋은 코드가 좋은 코드다.



# 7장 연산자

---

- 연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산등을 수행해 하나의 값을 만든다.
- 연산의 피연산자라 한다.

```jsx
//산술 연산자
5 * 4 // -> 20

//문자열 연결 연산자
'My name is ' + 'Lee' // -> 'My name is Lee'

//할당 연산자
color = 'red' // 'red'

//비교 연산자
3 > 5 // -> false

//논리 연산자
true && false // -> false

//타입 연산자
typeof 'Hi' // ->string
```

# 7.1 산술 연산자

- 산술연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
- 산술이 불가능한 경우, NaN을 반환한다.
- 산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.

## 7.1.1 이항 산술 연산자

- 이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/137f4e95-f637-4f7e-ba27-e0c1b82063df/Untitled.png)

```jsx
5 + 2; // 7
5 - 2; // 3
5 * 2; // 10
5 / 2; // 2.5
5 % 2; // 1
```

## 7.1.2 단항 산술 연산자

- 단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d7a3f444-d247-41cc-a01d-e87199d73747/Untitled.png)

```jsx
var x = 1;

//++ 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.
x++; // x = x + 1;
console.log(x); // 2

//-- 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.
x--; // x = x - 1;
console.log(x); // 1
```

- 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산를 수행한다.
- 피연산자 앞에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소 시킨다.

```jsx
var x = 5, result;

//선할당 후증가
result = x++;
console.log(result, x); // 5, 6

//선증가 후할당
result = ++x;
console.log(result, x); // 7, 7

//선할당 후감소
result = x--;
console.log(result, x); // 7, 6

//선감소 후할당
result = --x;
console.log(result, x); // 5, 5
```